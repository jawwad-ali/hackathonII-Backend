# Data Model: Todo Entity

**Feature**: 002-fastmcp-database-server
**Date**: 2025-12-29
**Status**: Design Complete

## Overview

This document defines the Todo entity data model for the FastMCP database server. The model uses SQLModel (combining SQLAlchemy and Pydantic) for type-safe database operations with built-in validation.

---

## Entity: Todo

### Purpose
Represents a single todo/task item in the system. Todos support basic CRUD operations and status-based lifecycle management (active → completed → archived, or permanent deletion).

### Table Name
`todos` (auto-generated by SQLModel from class name)

### Fields

| Field Name | Type | Constraints | Default | Description |
|------------|------|-------------|---------|-------------|
| `id` | Integer | PRIMARY KEY, AUTO INCREMENT, NOT NULL | Auto-generated | Unique identifier (PostgreSQL SERIAL) |
| `title` | String(200) | NOT NULL, INDEX | None | Todo title/summary |
| `description` | String(2000) | NULLABLE, INDEX | NULL | Detailed description (optional) |
| `status` | Enum(TodoStatus) | NOT NULL, INDEX | `"active"` | Current status (active/completed/archived) |
| `created_at` | DateTime | NOT NULL | UTC now | Timestamp when todo was created |
| `updated_at` | DateTime | NOT NULL | UTC now | Timestamp of last modification |

### Field Details

#### `id`: Integer (Primary Key)
- **Type**: PostgreSQL `SERIAL` (auto-incrementing integer)
- **Constraints**:
  - PRIMARY KEY
  - AUTO INCREMENT
  - NOT NULL
- **Purpose**: Unique identifier for each todo
- **Rationale**: Simple, efficient, sequential IDs suitable for typical todo operations. UUID considered but rejected for simplicity.

#### `title`: String (Max 200 chars)
- **Type**: `VARCHAR(200)`
- **Constraints**:
  - NOT NULL
  - MIN LENGTH: 1 (after stripping whitespace)
  - MAX LENGTH: 200 characters
  - INDEX (for search performance)
- **Validation**:
  - Must not be empty or whitespace-only
  - Automatically stripped of leading/trailing whitespace
- **Purpose**: Short, descriptive todo title
- **Rationale**: 200 chars balances expressiveness with database efficiency. Indexed for fast search operations.

#### `description`: String (Max 2000 chars, Optional)
- **Type**: `VARCHAR(2000)` or `TEXT`
- **Constraints**:
  - NULLABLE (optional field)
  - MAX LENGTH: 2000 characters (when provided)
  - INDEX (GIN index for full-text search)
- **Purpose**: Detailed explanation or notes for the todo
- **Rationale**: 2000 chars sufficient for detailed notes. Optional to support quick todo entry. Indexed for search functionality.

#### `status`: Enum (TodoStatus)
- **Type**: PostgreSQL ENUM or VARCHAR with validation
- **Allowed Values**:
  - `"active"` - Default state for new todos
  - `"completed"` - Todo is finished (soft delete - excluded from list_todos)
  - `"archived"` - Long-term storage (excluded from list_todos and search_todos)
- **Default**: `"active"`
- **Constraints**:
  - NOT NULL
  - Must be one of the enum values
  - INDEX (for efficient filtering in queries)
- **Purpose**: Lifecycle state management
- **Rationale**: Enum ensures data integrity. Soft delete (status change) preserves audit trail. Indexed for fast "active todos only" queries.

#### `created_at`: DateTime
- **Type**: `TIMESTAMP WITH TIME ZONE`
- **Constraints**:
  - NOT NULL
  - Auto-set on creation
- **Default**: `datetime.utcnow()` (UTC timezone)
- **Purpose**: Audit trail - when todo was created
- **Rationale**: Timezone-aware timestamps prevent ambiguity. UTC storage is best practice for multi-region systems.

#### `updated_at`: DateTime
- **Type**: `TIMESTAMP WITH TIME ZONE`
- **Constraints**:
  - NOT NULL
  - Auto-updated on modification
- **Default**: `datetime.utcnow()` (UTC timezone)
- **Update Trigger**: Automatically updated on any field modification
- **Purpose**: Audit trail - when todo was last modified
- **Rationale**: Enables tracking changes, useful for sync/caching strategies.

---

## SQLModel Implementation

### Todo Model Class

```python
from datetime import datetime, timezone
from enum import Enum
from typing import Optional

from sqlmodel import Field, SQLModel


class TodoStatus(str, Enum):
    """Todo status enumeration."""
    ACTIVE = "active"
    COMPLETED = "completed"
    ARCHIVED = "archived"


class Todo(SQLModel, table=True):
    """Todo entity for database persistence."""

    __tablename__ = "todos"

    id: Optional[int] = Field(default=None, primary_key=True, description="Unique todo ID")
    title: str = Field(
        ...,
        max_length=200,
        min_length=1,
        index=True,
        description="Todo title (required, max 200 chars)"
    )
    description: Optional[str] = Field(
        default=None,
        max_length=2000,
        index=True,
        description="Todo description (optional, max 2000 chars)"
    )
    status: TodoStatus = Field(
        default=TodoStatus.ACTIVE,
        index=True,
        description="Todo status (active/completed/archived)"
    )
    created_at: datetime = Field(
        default_factory=lambda: datetime.now(timezone.utc),
        nullable=False,
        description="Creation timestamp (UTC)"
    )
    updated_at: datetime = Field(
        default_factory=lambda: datetime.now(timezone.utc),
        nullable=False,
        description="Last update timestamp (UTC)"
    )

    class Config:
        """Pydantic model configuration."""
        json_schema_extra = {
            "example": {
                "id": 1,
                "title": "Buy groceries",
                "description": "Milk, eggs, bread",
                "status": "active",
                "created_at": "2025-12-29T12:00:00Z",
                "updated_at": "2025-12-29T12:00:00Z"
            }
        }
```

---

## State Transitions

### Valid State Transitions

```
        ┌─────────┐
        │ ACTIVE  │ ←─────┐
        └────┬────┘        │
             │             │ (reactivate)
             │             │
             ├─→ COMPLETED ┤
             │             │
             │             │
             ├─→ ARCHIVED  │
             │             │
             │             │
             └─→ DELETED (hard delete - permanent removal)
```

### Transition Rules

1. **ACTIVE → COMPLETED**:
   - Trigger: `update_todo(id, status="completed")`
   - Effect: Soft delete - todo excluded from `list_todos` and `search_todos`
   - Reversible: Yes (can reactivate)

2. **ACTIVE → ARCHIVED**:
   - Trigger: `update_todo(id, status="archived")`
   - Effect: Long-term storage - excluded from all default queries
   - Reversible: Yes (can reactivate)

3. **COMPLETED → ACTIVE** (Reactivation):
   - Trigger: `update_todo(id, status="active")`
   - Effect: Todo re-appears in `list_todos` and `search_todos`

4. **ANY STATE → DELETED** (Hard Delete):
   - Trigger: `delete_todo(id)`
   - Effect: Permanent removal from database (row deleted)
   - Reversible: No (data loss)

### State Constraints

- **Default State**: New todos created with `status="active"`
- **Immutable Fields**: `id`, `created_at` (cannot be modified after creation)
- **Auto-Updated Fields**: `updated_at` (automatically updated on any modification)

---

## Indexes

### Primary Index
- **Column**: `id`
- **Type**: PRIMARY KEY (B-tree, auto-generated)
- **Purpose**: Unique identification and fast lookups by ID

### Search Indexes

#### Title Index (B-tree)
```sql
CREATE INDEX idx_todos_title ON todos(title);
```
- **Purpose**: Fast keyword search in titles
- **Query Optimization**: `WHERE title ILIKE '%keyword%'`

#### Description Index (GIN - Full-Text Search)
```sql
CREATE INDEX idx_todos_description_gin ON todos USING GIN (to_tsvector('english', description));
```
- **Purpose**: Full-text search in descriptions
- **Query Optimization**: `WHERE to_tsvector('english', description) @@ to_tsquery('keyword')`

#### Status Index (B-tree)
```sql
CREATE INDEX idx_todos_status ON todos(status);
```
- **Purpose**: Fast filtering by status (e.g., active-only queries)
- **Query Optimization**: `WHERE status = 'active'`

### Composite Index (Future Enhancement)
```sql
CREATE INDEX idx_todos_status_created ON todos(status, created_at DESC);
```
- **Purpose**: Efficient "active todos sorted by creation date" queries
- **Deferred**: Not implemented in MVP, add if query performance requires

---

## Validation Rules

### Title Validation
1. **Non-Empty**: Title must not be empty after stripping whitespace
2. **Length**: 1-200 characters (after stripping)
3. **Sanitization**: Leading/trailing whitespace automatically removed

**Pydantic Validator**:
```python
from pydantic import field_validator

@field_validator("title", mode="after")
@classmethod
def validate_title(cls, value: str) -> str:
    """Ensure title is not empty after stripping whitespace."""
    stripped = value.strip()
    if not stripped:
        raise ValueError("Title cannot be empty or whitespace-only")
    return stripped
```

### Description Validation
1. **Optional**: Can be `None` or omitted
2. **Length**: Max 2000 characters (when provided)
3. **No Sanitization**: Preserve whitespace for formatting

### Status Validation
1. **Enum**: Must be one of `TodoStatus` enum values
2. **Default**: `"active"` for new todos
3. **Validation**: Pydantic enforces enum membership

---

## Database Constraints

### Table-Level Constraints

```sql
CREATE TABLE todos (
    id SERIAL PRIMARY KEY,
    title VARCHAR(200) NOT NULL CHECK (char_length(trim(title)) >= 1),
    description VARCHAR(2000),
    status VARCHAR(20) NOT NULL CHECK (status IN ('active', 'completed', 'archived')),
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW()
);
```

### Triggers (Future Enhancement)

**Auto-Update `updated_at`** (PostgreSQL function):
```sql
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ language 'plpgsql';

CREATE TRIGGER update_todos_updated_at
BEFORE UPDATE ON todos
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();
```

**Note**: For MVP, `updated_at` is manually set in Python code. Add trigger in production for reliability.

---

## Example Instances

### Example 1: Active Todo (Full Fields)
```json
{
  "id": 1,
  "title": "Buy groceries",
  "description": "Milk, eggs, bread, and coffee beans",
  "status": "active",
  "created_at": "2025-12-29T10:00:00Z",
  "updated_at": "2025-12-29T10:00:00Z"
}
```

### Example 2: Active Todo (Minimal Fields)
```json
{
  "id": 2,
  "title": "Call dentist",
  "description": null,
  "status": "active",
  "created_at": "2025-12-29T11:30:00Z",
  "updated_at": "2025-12-29T11:30:00Z"
}
```

### Example 3: Completed Todo
```json
{
  "id": 3,
  "title": "Submit expense report",
  "description": "Q4 2024 expenses for client meetings",
  "status": "completed",
  "created_at": "2025-12-20T09:00:00Z",
  "updated_at": "2025-12-28T15:45:00Z"
}
```

### Example 4: Archived Todo
```json
{
  "id": 4,
  "title": "Research new laptop",
  "description": "Compare MacBook Pro vs ThinkPad X1 Carbon",
  "status": "archived",
  "created_at": "2025-11-01T14:00:00Z",
  "updated_at": "2025-12-01T10:00:00Z"
}
```

---

## Query Patterns

### Retrieve Active Todos Only
```python
from sqlmodel import select

async with AsyncSession(engine) as session:
    result = await session.execute(
        select(Todo).where(Todo.status == TodoStatus.ACTIVE)
    )
    active_todos = result.scalars().all()
```

### Search Active Todos by Keyword
```python
from sqlmodel import or_

async with AsyncSession(engine) as session:
    keyword = "grocery"
    result = await session.execute(
        select(Todo).where(
            (Todo.status == TodoStatus.ACTIVE) &
            (
                Todo.title.ilike(f"%{keyword}%") |
                Todo.description.ilike(f"%{keyword}%")
            )
        )
    )
    matching_todos = result.scalars().all()
```

### Update Todo and Auto-Update Timestamp
```python
from datetime import datetime, timezone

async with AsyncSession(engine) as session:
    todo = await session.get(Todo, todo_id)
    todo.title = "Updated title"
    todo.updated_at = datetime.now(timezone.utc)  # Manual update (or use trigger)
    await session.commit()
    await session.refresh(todo)
```

---

## Performance Considerations

### Index Usage
- **list_todos**: Uses `idx_todos_status` (B-tree) for fast status filtering
- **search_todos**: Uses `idx_todos_title` and `idx_todos_description_gin` for keyword matching
- **get by ID**: Uses PRIMARY KEY index (optimal performance)

### Expected Query Performance
- **list_todos** (100 active todos): <10ms
- **search_todos** (keyword match, 100 todos): <50ms (with GIN index)
- **create_todo**: <20ms (insert + auto-increment)
- **update_todo**: <30ms (select + update + commit)
- **delete_todo**: <20ms (delete by ID)

### Scalability
- **Vertical**: SQLModel + asyncpg handle 1000s of queries/sec on modern hardware
- **Horizontal**: Neon serverless auto-scales read replicas for read-heavy workloads
- **Bottleneck**: Full-text search on large datasets (>100k todos) may require dedicated search service (Elasticsearch/Meilisearch)

---

## Migration Strategy

### Initial Schema Creation
```python
from sqlalchemy.ext.asyncio import create_async_engine
from sqlmodel import SQLModel

async def create_db_and_tables():
    """Creates database tables if they don't exist."""
    async with engine.begin() as conn:
        await conn.run_sync(SQLModel.metadata.create_all)
```

### Future Schema Changes
- **Tool**: Alembic (SQLAlchemy migration tool)
- **Process**:
  1. Modify `Todo` model in Python code
  2. Generate migration: `alembic revision --autogenerate -m "description"`
  3. Review migration SQL
  4. Apply migration: `alembic upgrade head`

**Note**: Alembic integration deferred to post-MVP. For MVP, drop/recreate tables in development.

---

## Summary

- **Entity**: Todo (single table, 6 fields)
- **Primary Key**: Auto-increment integer (`id`)
- **Lifecycle**: Active → Completed/Archived (soft delete) or Deleted (hard delete)
- **Validation**: Pydantic field validators for title, description, status
- **Indexes**: 3 indexes (status, title, description GIN)
- **Timestamps**: Auto-managed `created_at` and `updated_at` (UTC timezone-aware)
- **ORM**: SQLModel (combines SQLAlchemy + Pydantic for type safety)

**Next**: See `contracts/` for MCP tool schemas that operate on this entity.
